!--------------------------------------------------
!  DIIS
!  This module uses Puley's Direct Inversion in 
!  Iterative Subspace method to accelerate the 
!  convergence of a set of parameters
!--------------------------------------------------
MODULE DIIS
  IMPLICIT NONE
  private

! LIST OF MODULE VARIABLES
! ndiis    INTEGER
!          Dimensionality of DIIS space
! m        INTEGER
!          Dimensionality of parameter space
! ndata    INTEGER
!          Number of sets of parameters and expected changes
!          that is already stored.
! nmin     INTEGER
!          Minimum number of parameters and displacements
!          requred to start DIIS interpolation
! ptop     INTEGER
!          Position of the top of the parameters stack.
! cdata    DOUBLE PRECISION,dimension(ndiis,m),allocatable
!          Contains the last $(ndiis) sets of parameters
!          that will be used to generate the optimal set
! ddata    DOUBLE PRECISION,dimension(ndiis,m),allocatable
!          Predicted displacements for the last $(ndiis) steps
!          that will be used to predict the optimal set of
!          parameters.
  INTEGER          ::  ndiis,ndata,ptop,m,nmin
  DOUBLE PRECISION,dimension(:,:),allocatable :: cdata
  DOUBLE PRECISION,dimension(:,:),allocatable :: ddata

  public :: initDIIS,pushDIIS,cleanDIIS,pushDIISg,initDIISg

CONTAINS
!initDIIS() Initializes DIIS data structures
! n_diis    (input) INTEGER
!           Dimensionality of DIIS space
! n_min     (input) INTEGER
!           Minimum number of parameters and displacements
!           requred to start DIIS interpolation
! nparam    (input) INTEGER
!           Dimensionality of parameter space
! initparam (input) DOUBLE PRECISION,dimension(nparam)
!           Initial values of the parameters.
 SUBROUTINE initDIIS(n_diis,n_min,nparam,initparam)
   IMPLICIT NONE
   INTEGER,INTENT(IN)         :: n_diis,nparam,n_min
   DOUBLE PRECISION,INTENT(IN):: initparam(nparam)
   m       = nparam
   ndiis   = n_diis
   nmin    = n_min
   ndata   = 0
   ptop  = 1
   allocate(cdata(ndiis,m))
   allocate(ddata(ndiis,m))
   cdata = 0d0
   ddata = 0d0
   cdata(1,:)=initparam
 END SUBROUTINE initDIIS
!-------------------------------------------------------------
! pushDIIS() takes the displaced geometry from the current geometry,
! generated by any quasi-Newton or simple relaxation method, stores
! the data into data structure, then perform a DIIS interpolation
! and returns the DIIS predicted parameters that will produce minimal
! step length.  The new parameters are also stored into parameter list.
! newparam    (input/output) DOUBLE PRECISION,dimension(m)
!             On entry, contains the set of parameters generated by
!             taking one step of Newton or simple relaxation from the
!             last set of parameters, generated by last pushDIIS() or
!             imported from initDIIS().
!             On exit, contains the DIIS predicted minimal step length
!             parameters.
 SUBROUTINE pushDIIS(newparam)
   IMPLICIT NONE
   DOUBLE PRECISION,INTENT(INOUT)              :: newparam(m)
   double precision,dimension(:,:),allocatable :: B,Z
   double precision,dimension(:),allocatable   :: c,w,WORK
   integer,dimension(:),allocatable            :: IWORK,ISUPPZ
   double precision :: dtest(1),wmx
   integer          :: itest(1),i,INFO

   ddata(ptop,:)=newparam-cdata(ptop,:)
   cdata(ptop,:)=newparam
   ndata=ndata+1
   if(ndata>ndiis)ndata=ndiis
   if(ndata>=nmin)then
     allocate(B(ndata+1,ndata+1))
     allocate(Z(ndata+1,ndata+1))
     allocate(c(ndata+1))
     allocate(w(ndata+1))
     allocate(ISUPPZ(ndata*2+2))
     CALL DSYRK('U','N',ndata,m,dble(1),ddata,ndiis,dble(0),B,ndata+1)
     B(1:ndata,ndata+1)=dble(-1)
     B(ndata+1,ndata+1)=dble(0)
     CALL DSYEVR('V','A','U',ndata+1,B,ndata+1,0.,0.,0,0,1D-10,i,W,Z,  &
                        ndata+1,ISUPPZ,dtest,int(-1),itest,int(-1),INFO)
     allocate(WORK( int(dtest(1)) ))
     allocate(IWORK( itest(1) ))
     CALL DSYEVR('V','A','U',ndata+1,B,ndata+1,0.,0.,0,0,1D-10,i,W,Z,  &
                 ndata+1,ISUPPZ,WORK,int(dtest(1)),IWORK,itest(1),INFO)
     wmx=maxval(abs(w))
     do i=1,ndata+1
       if(abs(W(i))>1D-10)then
         w(i)=-Z(ndata+1,i)/w(i)
       else
         w(i)=0
       end if
     end do
     CALL DGEMV('N',ndata+1,ndata+1,dble(1),Z,ndata+1,w,int(1),&
                                                      dble(0),c,int(1))
     CALL DGEMV('T',ndata,m,dble(1),cdata,ndiis,c,int(1),dble(0),&
                                                       newparam,int(1))
     deallocate(w)
     deallocate(WORK)
     deallocate(IWORK)
     deallocate(ISUPPZ)
     deallocate(c)
     deallocate(B)
     deallocate(Z)
   end if
   ptop=ptop+1
   if(ptop>ndiis)ptop=ptop-ndiis
   cdata(ptop,:)=newparam
 END SUBROUTINE pushDIIS
!--------------------------------------------------------
! cleanDIIS() releases memory of DIIS module structures
 SUBROUTINE cleanDIIS()
   IMPLICIT NONE
   ndata=0
   ptop=1
   ndiis=0
   nmin=0
   if(allocated(ddata))deallocate(ddata)
   if(allocated(cdata))deallocate(cdata) 
 END SUBROUTINE cleanDIIS
!initDIISg() Initializes DIIS data structures
! n_diis     (input) INTEGER
!            Dimensionality of DIIS space
! n_min      (input) INTEGER
!            Minimum number of parameters and displacements
!            requred to start DIIS interpolation
! nparam     (input) INTEGER
!            Dimensionality of parameter space
! initparam  (input) DOUBLE PRECISION,dimension(nparam)
!            Initial values of the parameters.
! initgrad   (input) DOUBLE PRECISION,dimension(nparam)
!            Initial gradient vector at the given parameters
 SUBROUTINE initDIISg(n_diis,n_min,nparam,initparam,initgrad)
   IMPLICIT NONE
   INTEGER,INTENT(IN)         :: n_diis,nparam,n_min
   DOUBLE PRECISION,INTENT(IN):: initparam(nparam),initgrad(nparam)
   m       = nparam
   ndiis   = n_diis
   nmin    = n_min
   ndata   = 1
   ptop  = 2
   allocate(cdata(ndiis,m))
   allocate(ddata(ndiis,m))
   cdata = 0d0
   ddata = 0d0
   cdata(1,:)=initparam
   ddata(1,:)=initgrad
 END SUBROUTINE initDIISg
!-------------------------------------------------------------
! pushDIISg() inserts the new parameters and gradients into the data set,
! then perform DIIS interpolation based on the updated data.
! newparam    (input) DOUBLE PRECISION,dimension(m)
!             contains the set of parameters at the new data point
! newgrad     (input) contains the gradient vector at new data point 
! optparam    (output) contains the DIIS predicted minimal step length
!             parameters.
 SUBROUTINE pushDIISg(newparam,newgrad,optparam)
   IMPLICIT NONE
   DOUBLE PRECISION,INTENT(IN),dimension(m)    :: newparam,newgrad
   DOUBLE PRECISION,INTENT(OUT),dimension(m)   :: optparam 
   double precision,dimension(:,:),allocatable :: B,Z
   double precision,dimension(:),allocatable   :: c,w,WORK
   integer,dimension(:),allocatable            :: IWORK,ISUPPZ
   double precision :: dtest(1),wmx
   integer          :: itest(1),i,INFO

   optparam  = newparam
   cdata(ptop,:) = newparam
   ddata(ptop,:) = newgrad
   ptop=ptop+1
   if(ptop>ndiis)ptop=ptop-ndiis
   ndata=ndata+1
   if(ndata>ndiis)ndata=ndiis
   if(ndata>=nmin)then
     allocate(B(ndata+1,ndata+1))
     allocate(Z(ndata+1,ndata+1))
     allocate(c(ndata+1))
     allocate(w(ndata+1))
     allocate(ISUPPZ(ndata*2+2))
     CALL DSYRK('U','N',ndata,m,dble(1),ddata,ndiis,dble(0),B,ndata+1)
     B(1:ndata,ndata+1)=dble(-1)
     B(ndata+1,ndata+1)=dble(0)
     CALL DSYEVR('V','A','U',ndata+1,B,ndata+1,0.,0.,0,0,1D-10,i,W,Z,  &
                        ndata+1,ISUPPZ,dtest,int(-1),itest,int(-1),INFO)
     allocate(WORK( int(dtest(1)) ))
     allocate(IWORK( itest(1) ))
     CALL DSYEVR('V','A','U',ndata+1,B,ndata+1,0.,0.,0,0,1D-10,i,W,Z,  &
                 ndata+1,ISUPPZ,WORK,int(dtest(1)),IWORK,itest(1),INFO)
     wmx=maxval(abs(w))
     do i=1,ndata+1
       if(abs(W(i))>1D-10)then
         w(i)=-Z(ndata+1,i)/w(i)
       else
         w(i)=0d0
       end if
     end do
     CALL DGEMV('N',ndata+1,ndata+1,dble(1),Z,ndata+1,w,int(1),&
                                                      dble(0),c,int(1))
     CALL DGEMV('T',ndata,m,dble(1),cdata,ndiis,c,int(1),dble(0),&
                                                       optparam,int(1))
     deallocate(w)
     deallocate(WORK)
     deallocate(IWORK)
     deallocate(ISUPPZ)
     deallocate(c)
     deallocate(B)
     deallocate(Z)
   end if
   
 END SUBROUTINE pushDIISg
END MODULE DIIS
