      SUBROUTINE WRITPK(IFTN,A,LA,NA,NHEX)
C     ENTRY WRPK(NA)
C     ENTRY INITPK (RNAME)
C     ENTRY EXITPK
C
C      FUNCTION:
C
C      WRITPK:WRITE ONE SELF DEFINED PACKED LOGICAL RECORD OF FLOATING
C             POINT REAL*8 NUMBERS.MUST BE USED FOR FIRST WRITE.
C      WRPK:  WRITE ONE SELF DEFINED PACKED LOGICAL RECORD OF FLOATING
C             POINT REAL*8 NUMBERS.MAY BE USED FOR WRITES AFTER THE
C             FIRST,IF ALL ARGUMENTS OTHER THAN NA HAVE SAME VALUE AS
C             LAST EXECUTED WRITPK.
C      INITPK:INITIALIZE PACKING STATISTICS.(EXECUTE BEFORE FIRST
C             WRITPK OR WRPK).
C      EXITPK:PRINT PACKING STATISTICS ACCUMULATED OVER ALL WRITES (BY
C             WRITPK OR WRPK) EXECUTED SINCE THE LAST INITPK.
C
C      ARGUMENT LIST:
C
C      IFTN:  FORTRAN NUMBER OF SEQUENTIAL ACCESS DATASET.
C      A:     UNPACKED ARRAY BEING WRITTEN.
C      LA:    ARRAY WHERE PACKING IS DONE.CAN BE SAME STORAGE AREA AS
C             A,IF UNPACKED NUMBERS CAN BE OVERWRITTEN.
C      NA:    IABS(NA) IS THE NUMBER OF REAL*8'S IN A.(CAN BE 0).
C      NHEX:  NUMBER OF HEXADECIMAL PLACES RETAINED IN THE FRACTIONAL
C             PART OF THE NUMBER.
C             (SPECIAL CASE,NHEX.EQ.-100;EQUIVALENT TO NO PACKING WITH
C             MAXIMUM EFFICIENCY).
C      RNAME: USER GIVEN NAME OF DATASET.
C
C      SUBROUTINE IS MACHINE DEPENDENT. IT ASSUMES THE IBM 360
C      FLOATING POINT WORD FORMAT.
      IMPLICIT REAL*8(A-H,O-Z),LOGICAL*1(L),INTEGER*4(I-K,M,N)
      DIMENSION A(2),LA(16),LNUM(8),LPNUM(8),LWORK(4),LPACK(8),
     1       LCW(1000)
      DIMENSION RNAME(2)
      EQUIVALENCE (CNUM,LNUM(1)),(PCNUM,LPNUM(1)),(IWORK,LWORK(1))
      DATA NCWBUF/1000/
      DATA IZERO/0/
      DATA IFLGNT/0/
   10 FORMAT (' ',5Z20)
   11 FORMAT (' ',10I8)
   12 FORMAT (' ',5F20.10)
   13 FORMAT (' ',5(8Z2,4X))
   20 FORMAT (' DATA LIST ',20X,8A8/' ','HAS BEEN PACKED.',I9,
     1   ' R*8 WORDS INTO ',I9,' BYTES,PACKING FRACTION=',F8.4,
     2   2X,'NHEX=',I4/' ',I9,' CODE WORD BYTES,',I9,
     3   ' DATA BYTES,',I9,' LOGICAL RECORDS')
      NCWBFM=NCWBUF-4
      ENTRY WRPK(NA)
C      SAVE NA WITH SIGN IN ISAVNA.USER WILL SET IT NEGATIVE IF
C      THIS WRITE CALL COMPLETES THE WRITING OF THE DATA LIST,
C      AND ON READING HE WANTS TO TERMINATE READING BY TESTING
C      ON SIGN OF NA.
      ISAVNA=NA
      NA=IABS(NA)
C     WRITE (6,11) NA,NHEX
C     WRITE (6,10) (A(I),I=1,NA)
C     WRITE (6,12) (A(I),I=1,NA)
      IF (NA.EQ.0)  GO TO 900
      IF (NHEX.EQ.-100)  GO TO 500
C      MULTIPLY STARTING ARRAY BY 2. TO STORE TO DESIRED ACCURACY
C      BECAUSE LAST STORED BIT IS RESERVED FOR THE SIGN OF THE NUMBER
      DO 100 I=1,NA
  100 A(I)=2.D0*A(I)
C      INITIALIZE COUNTS FOR FIRST LOGICAL RECORD OF FIRST RECORD PAIR
      IFINAL=0
      INA=0
      ILCW=0
      ILA=0
C      INITIALIZE IBYTEC CONTAINING CURRENT IBYTE
      IBYTEC=-1
C      LOOP OVER NA WORDS IN A
Cibm 
      I=1
      IF ( I .GT. NA) GO TO 400
  399 CONTINUE
C     DO 400 I=1,NA
Cibm
C      PACK NUMBER.PRODUCE IBYTE,LPACK(J),J=1,IBYTE
      CNUM=A(I)
      ISIGN=0
      PCNUM=DABS(CNUM)
      IF (CNUM.LT.0.D0)  ISIGN=1
      IWORK=0
      LWORK(4)=LPNUM(1)
      IMOVE=IWORK-64+NHEX
      IF (IMOVE.GT.0)  GO TO 50
      IBYTE=0
      GO TO 250
   50 IF (IMOVE.LE.12)  GO TO 70
      IBYTE=8
      DO 60 J=1,8
   60 LPACK(J)=LNUM(J)
      GO TO 250
   70 IBYTE=(IMOVE+1)/2
      GO TO (130,145,130,144,120,143,120,142,110,141,110,140),IMOVE
  110 IWORK=0
      LWORK(2)=LNUM(5)
      LWORK(3)=LNUM(6)
      LWORK(4)=LNUM(7)
      IWORK=IWORK*16
      LPACK(5)=LWORK(2)
      LPACK(6)=LWORK(3)
  120 IWORK=0
      LWORK(2)=LNUM(3)
      LWORK(3)=LNUM(4)
      LWORK(4)=LNUM(5)
      IWORK=IWORK*16
      LPACK(3)=LWORK(2)
      LPACK(4)=LWORK(3)
  130 IWORK=0
      LWORK(2)=LNUM(2)
      LWORK(3)=LNUM(3)
      IWORK=IWORK*16
      LPACK(1)=LWORK(1)
      LPACK(2)=LWORK(2)
      GO TO 150
  140 LPACK(6)=LNUM(7)
  141 LPACK(5)=LNUM(6)
  142 LPACK(4)=LNUM(5)
  143 LPACK(3)=LNUM(4)
  144 LPACK(2)=LNUM(3)
  145 LPACK(1)=LNUM(2)
  150 IWORK=0
      LWORK(4)=LPACK(IBYTE)
      IWORK=IWORK/2
      IWORK=IWORK*2
      IF (ISIGN.EQ.1)  IWORK=IWORK+1
      LPACK(IBYTE)=LWORK(4)
  250 IF (IBYTE.NE.IBYTEC)  GO TO 280
C      INCREMENT IWORD,STORE PACKED BYTES INTO LA
      IWORD=IWORD+1
  260 IF (IBYTE.EQ.0)  GO TO 272
      DO 270 J=1,IBYTE
  270 LA(ILA+J)=LPACK(J)
      ILA=ILA+IBYTE
  272 INA=INA+1
      GO TO 400
  280 IF (IBYTEC.NE.-1)  GO TO 290
C      START A NEW CODE WORD;  IBYTE HAS CHANGED FROM LAST NUMBER
C      TO CURRENT NUMBER
  281 IWORD=1
      IBYTEC=IBYTE
      GO TO 260
C      STORE OLD CODE WORD INTO LCW
  290 IWORK=0
      IF (IBYTEC.EQ.8)  IBYTEC=7
      IF (IWORD.GT.15)  GO TO 300
      IWORK=(16+IWORD)*8+IBYTEC
      LCW(ILCW+1)=LWORK(4)
      ILCW=ILCW+1
      GO TO 340
  300 IF (IWORD.GT.255)  GO TO 310
      IWORK=(16+IBYTEC)*256+IWORD
      LCW(ILCW+1)=LWORK(3)
      LCW(ILCW+2)=LWORK(4)
      ILCW=ILCW+2
      GO TO 340
  310 IF (IWORD.GT.65535)  GO TO 320
      IWORK=(24+IBYTEC)*65536+IWORD
      LCW(ILCW+1)=LWORK(2)
      LCW(ILCW+2)=LWORK(3)
      LCW(ILCW+3)=LWORK(4)
      ILCW=ILCW+3
      GO TO 340
  320 IWORK=(32+IBYTEC)*65536*256+IWORD
      DO 321 K=1,4
  321 LCW(ILCW+K)=LWORK(K)
      ILCW=ILCW+4
  340 IF (ILCW.GT.NCWBFM)  GO TO 350
      IF (IFINAL.GE.0)  GO TO 281
  350 IF (IFINAL.GE.0)  IFINAL=IFINAL+1
C      WRITE CURRENT PAIR OF LOGICAL RECORDS
C      WRITE INA WITH NEGATIVE SIGN IF THIS CALL TO WRITPK OR WRPK
C      COMPLETES THE WRITING OF THIS DATA LIST
      IWNA=INA
      IF (ISAVNA.LT.0)  IWNA=-IWNA
      WRITE (IFTN) IFINAL,IWNA,ILCW,ILA,NHEX
      IF (IFLGNT.EQ.0)  GO TO 351
      NTBYTE=NTBYTE+ILA+ILCW+20
      NR8=NR8+INA
      NCB=NCB+ILCW
      NDB=NDB+ILA
      NLR=NLR+2
  351 IF (ILA.GT.0)  GO TO 360
      WRITE (IFTN) (LCW(K),K=1,ILCW)
      GO TO 370
  360 CALL WRITB1 (IFTN,LCW,ILCW,LA,ILA)
  370 IF (IFINAL.LT.0)  GO TO 990
      INA=0
      ILCW=0
      ILA=0
      GO TO 281
Cibm
      I=I+1
  400 CONTINUE
      IF ( I .LE. NA )  GO TO 399
Cibm
      IFINAL=-IFINAL-1
      GO TO 290
C      NO PACKING:  WRITE SINGLE PAIR OF LOGICAL RECORDS
  500 IFINAL=-1
C     WRITE(6,*)' AT 500  IFTN NA ',IFTN,NA
      NF=8*NA
      WRITE (IFTN) IFINAL,ISAVNA,IZERO,NF,NHEX
      CALL WRITB2 (IFTN,A,NA)
      IF (IFLGNT.EQ.0)  GO TO 1000
      NTBYTE=NTBYTE+8*NA+20
      NR8=NR8+NA
      NDB=NDB+8*NA
      NLR=NLR+2
      GO TO 1000
  900 IFINAL=-1
      DO 901 I=1,2
  901 WRITE (IFTN) IFINAL,NA,NA,NA,NHEX
      IF (IFLGNT.EQ.0)  GO TO 1000
      NTBYTE=NTBYTE+40
      NLR=NLR+2
      GO TO 1000
  990 DO 991 I=1,NA
  991 A(I)=A(I)*0.5D0
 1000 NTBYTE=NTBYTE
C     WRITE (6,11) NA,NHEX,NTBYTE
      RETURN
      ENTRY INITPK (RNAME)
      IFLGNT=1
      NTBYTE=0
      NR8=0
      NCB=0
      NDB=0
      NLR=0
      RETURN
      ENTRY EXITPK
      PF=1.D10
      IF (NR8.EQ.0)  GO TO 1100
      PFN=NTBYTE
      PFD=8*NR8
      PF=PFN/PFD
 1100 WRITE (6,20) (RNAME(I),I=1,8),NR8,NTBYTE,PF,NHEX,NCB,NDB,NLR
      IFLGNT=0
      NR8=0
      RETURN
      END
      SUBROUTINE READPK(IFTN,A,LA,NA,NHEX,IERR,IEND)
C     ENTRY RDPK (NA,IERR,IEND)
C     ENTRY ADVPK (IFTN,NA,IERR,IEND)
C
C      FUNCTION:
C
C      READPK:READ ONE SELF DEFINED PACKED LOGICAL RECORD OF FLOATING
C             POINT REAL*8 NUMBERS.MUST BE USED FOR FIRST READ.
C      RDPK:  READ ONE SELF DEFINED PACKED LOGICAL RECORD OF FLOATING
C             POINT REAL*8 NUMBERS.MAY BE USED FOR READS AFTER THE
C             FIRST,IF ALL ARGUMENTS OTHER THAN NA HAVE SAME VALUE AS
C             LAST EXECUTED READPK.
C      ADVPK: ADVANCE OVER ONE SELF DEFINED PACKED LOGICAL RECORD OF
C             FLOATING POINT REAL*8 NUMBERS.
C
C      ARGUMENT LIST:
C
C      IFTN:  FORTRAN NUMBER OF SEQUENTIAL ACCESS DATASET.
C      A:     ARRAY OF UNPACKED FLOATING POINT NUMBERS RETURNED TO USER.
C      LA:    ARRAY WHERE PACKED NUMBERS ARE READ FROM IFTN BEFORE
C             UNPACKING.CAN BE SAME STORAGE AREA AS A IF UNPACKED
C             NUMBERS CAN BE OVERWRITTEN.
C      NA:    RETURNED TO USER FROM SELF DEFINED PACKED LOGICAL RECORD.
C             SIGN AS GIVEN BY USER.
C      NHEX:  RETURNED TO USER FROM SELF DEFINED PACKED LOGICAL RECORD.
C      IERR:  =0,IF NO ERR ON FORTRAN READ.
C             =1,IF ERR CONDITION ON FORTRAN READ.
C      IEND:  =0,IF NO END ON FORTRAN READ.
C             =1,IF END CONDITION ON FORTRAN READ.
C
C      SUBROUTINE IS MACHINE DEPENDENT. IT ASSUMES THE IBM 360
C      FLOATING POINT WORD FORMAT.
      IMPLICIT REAL*8(A-H,O-Z),LOGICAL*1(L),INTEGER*4(I-K,M,N)
      DIMENSION A(2),LA(16),LCW(1000),LNUM(8),LWORK(4),LWORD(4),
     1     LBYTE(4),LNCW(4),ICTAB(6)
      EQUIVALENCE (CNUM,LNUM(1)),(IWORK,LWORK(1)),(IWORD,LWORD(1)),
     1     (IBYTE,LBYTE(1)),(NCW,LNCW(1))
   10 FORMAT (' ',5Z20)
   11 FORMAT (' ',10I8)
   12 FORMAT (' ',5F20.10)
   13 FORMAT (' ',5(8Z2,4X))
      ENTRY RDPK (NA,IERR,IEND)
      ISAVNA=0
      NAFLG=0
      INAS=0
      IERR=0
      IEND=0
  100 READ (IFTN,ERR=101,END=102)  IFINAL,INA,ILCW,ILA,NHEX
      IF (INA.LT.0)  ISAVNA=1
      INA=IABS(INA)
C     WRITE (6,11) IFINAL,INA,ILCW,ILA,NHEX
      GO TO 110
  101 IERR=IERR+1
      GO TO 900
  102 IEND=IEND+1
      GO TO 900
  110 INAF=INAS+INA
      IF (INA.EQ.0)  GO TO 120
      IF (NHEX.NE.-100)  GO TO 150
      CALL READB2 (IFTN,A,INA,IERR,IEND)
      IF ((IERR.EQ.1).OR.(IEND.EQ.1))  GO TO 900
      GO TO 800
  120 IF (NAFLG.EQ.1)  GO TO 800
      NAFLG=NAFLG+1
      GO TO 100
  150 IF (ILA.NE.0)  GO TO 300
      READ (IFTN,ERR=101,END=102)  (LCW(K),K=1,ILCW)
C     WRITE (6,13) (LCW(I),I=1,ILCW)
      GO TO 310
  300 ILAC=(8*INAF)-ILA
      CALL READB1 (IFTN,LCW,ILCW,LA(ILAC+1),ILA,IERR,IEND)
      IF ((IERR.EQ.1).OR.(IEND.EQ.1))  GO TO 900
  310 ILCWC=0
      DO 320 I=1,6
  320 ICTAB(I)=(2*I)+64-NHEX
      GO TO 330
  330 IWORD=0
      IBYTE=0
      IWORK=0
      LWORK(4)=LCW(ILCWC+1)
      IF (IWORK.LT.128)  GO TO 350
      IWORK=(IWORK-128)*32
      LWORD(4)=LWORK(3)
      LWORK(3)=LWORK(4)
      IWORK=IWORK*8
      LBYTE(4)=LWORK(2)
      ILCWC=ILCWC+1
      GO TO 370
  350 IWORK=IWORK*32
      LBYTE(4)=LWORK(4)
      IBYTE=IBYTE/32
      NCW=0
      LNCW(4)=LWORK(3)
      NCWM=NCW-1
      GO TO (351,352,353),NCWM
  351 ASSIGN 363 TO JUMP
      GO TO 355
  352 ASSIGN 362 TO JUMP
      GO TO 355
  353 ASSIGN 361 TO JUMP
  355 K=NCW-3
      GO TO JUMP,(361,362,363)
  361 LWORD(2)=LCW(ILCWC+K+1)
  362 LWORD(3)=LCW(ILCWC+K+2)
  363 LWORD(4)=LCW(ILCWC+K+3)
      ILCWC=ILCWC+NCW
  370 IF (IBYTE.EQ.0)  GO TO 400
      IF (IBYTE.EQ.7)  GO TO 450
      GO TO 500
  400 DO 410 J=1,IWORD
  410 A(INAS+J)=0.D0
      GO TO 700
  450 DO 460 J=1,IWORD
      LNUM(1)=LA(ILAC+1)
      LNUM(2)=LA(ILAC+2)
      LNUM(3)=LA(ILAC+3)
      LNUM(4)=LA(ILAC+4)
      LNUM(5)=LA(ILAC+5)
      LNUM(6)=LA(ILAC+6)
      LNUM(7)=LA(ILAC+7)
      LNUM(8)=LA(ILAC+8)
      ILAC=ILAC+8
  460 A(INAS+J)=CNUM
      GO TO 700
  500 GO TO (501,502,503,504,505,506),IBYTE
  501 ASSIGN 526 TO JUMP
      GO TO 509
  502 ASSIGN 525 TO JUMP
      GO TO 509
  503 ASSIGN 524 TO JUMP
      GO TO 509
  504 ASSIGN 523 TO JUMP
      GO TO 509
  505 ASSIGN 522 TO JUMP
      GO TO 509
  506 ASSIGN 521 TO JUMP
  509 K=IBYTE-6
      JI=INAS+1
      JF=INAS+IWORD
      DO 540 J=JI,JF
      ILAP=ILAC+K
      IWORK=0
      LWORK(4)=LA(ILAC+IBYTE)
      IWORK=(IWORK*128)+ICTAB(IBYTE)
      LNUM(1)=LWORK(4)
      GO TO JUMP,(521,522,523,524,525,526)
  521 LNUM(K+2)=LA(ILAP+1)
  522 LNUM(K+3)=LA(ILAP+2)
  523 LNUM(K+4)=LA(ILAP+3)
  524 LNUM(K+5)=LA(ILAP+4)
  525 LNUM(K+6)=LA(ILAP+5)
  526 LNUM(K+7)=LA(ILAP+6)
      ILAC=ILAC+IBYTE
      A(J)=CNUM
  540 CONTINUE
      GO TO 700
  700 INAS=INAS+IWORD
      IF (ILCWC.NE.ILCW)  GO TO 330
      IF (IFINAL.GE.0)  GO TO 100
  750 DO 760 I=1,INAF
  760 A(I)=A(I)*0.5D0
  800 NA=INAF
C      RETURN NA WITH A NEGATIVE SIGN IF THIS COMPLETES THE READING
C      OF THE DATA LIST
      IF (ISAVNA.EQ.1)  NA=-NA
C     WRITE (6,11) NA
C     WRITE (6,10) (A(I),I=1,NA)
C     WRITE (6,12) (A(I),I=1,NA)
  900 RETURN
      ENTRY ADVPK (IFTN,NA,IERR,IEND)
C      SIMULATES FORTRAN SKIP OVER A SINGLE RECORD,BY READING WITH
C      NO IO LIST.INTHE 'PACK' FORMAT THE SKIP IS OVER THE DATA
C      WRITTEN BY A CALL TO WRITPK OR WRPK.
C      NEGATIVE NA CAN BE USED AS A TERMINATION FLAG
      NA=0
  901 READ (IFTN,ERR=101) IFINAL,INA
      NA=NA+INA
      READ (IFTN,ERR=101,END=102)
      IF (IFINAL.GT.0)  GO TO 901
      RETURN
      END
      SUBROUTINE RETPK (IFTN,LCW,ILCW,LA,ILA,NA,NHEX,IERR,IEND)
C
C      FUNCTION:
C
C      RETPK: READ ONE SELF DEFINED PACKED LOGICAL RECORD OF FLOATING
C             POINT REAL*8 NUMBERS,AND RETURN TO THE USER IN PACKED
C             FORM.
C
C      ARGUMENT LIST:
C
C      IFTN:  FORTRAN NUMBER OF SEQUENTIAL ACCESS DATASET.
C      LCW:   ARRAY OF CODEWORDS RETURNED TO USER.
C      ILCW:  NUMBER OF BYTES IN LCW.
C      LA:    ARRAY OF PACKED DATA BYTES RETURNED TO USER.
C             IF NHEX.NE.-100,PACKED DATA BYTES ARE 2*ORIGINAL NUMBERS.
C             IF NHEX.EQ.-100,DATA BYTES ARE ORIGINAL NUMBERS.
C      ILA:   NUMBER OF BYTES IN LA.
C      NA:    RETURNED TO USER FROM SELF DEFINED PACKED LOGICAL RECORD.
C             SIGN AS GIVEN BY USER.
C      NHEX:  RETURNED TO USER FROM SELF DEFINED PACKED LOGICAL RECORD.
C      IERR:  =0,IF NO ERR ON FORTRAN READ.
C             =1,IF ERR CONDITION ON FORTRAN READ.
C      IEND:  =0,IF NO END ON FORTRAN READ.
C             =1,IF END CONDITION ON FORTRAN READ.
C
      IMPLICIT REAL*8(A-H,O-Z),LOGICAL*1(L),INTEGER*4(I-K,M,N)
      DIMENSION LCW(2),LA(2)
   10 FORMAT (' ',5Z20)
   11 FORMAT (' ',10I8)
   12 FORMAT (' ',5F20.10)
   13 FORMAT (' ',5(4X,8Z2))
      NAFLG=0
      ILCW=0
      ILA=0
      NA=0
  100 READ (IFTN,ERR=101,END=102) IFINAL,NAC,ILCWC,ILAC,NHEX
      MNAC=IABS(NAC)
C     WRITE (6,11) IFINAL,NAC,ILCWC,ILAC,NHEX
      GO TO 120
  101 IERR=1
      GO TO 200
  102 IEND=1
      GO TO 200
  120 ILCWS=ILCW+1
      ILAS=ILA+1
      ILCW=ILCW+ILCWC
      ILA=ILA+ILAC
      NA=NA+NAC
      IF (NAC.EQ.0)  GO TO 130
      IF (NHEX.EQ.-100)  GO TO 140
      GO TO 150
  130 IF (NAFLG.EQ.1)  GO TO 200
      NAFLG=NAFLG+1
      GO TO 100
  140 CALL READB2 (IFTN,LA,MNAC,IERR,IEND)
      IF ((IERR.EQ.1).OR.(IEND.EQ.1))  GO TO 200
      GO TO 200
  150 IF (ILAC.NE.0)  GO TO 160
      READ (IFTN,ERR=101,END=102) (LCW(K),K=ILCWS,ILCW)
      GO TO 170
  160 CALL READB1 (IFTN,LCW(ILCWS),ILCWC,LA(ILAS),ILAC,IERR,IEND)
      IF ((IERR.EQ.1).OR.(IEND.EQ.1))  GO TO 200
  170 IF (IFINAL.GT.0)  GO TO 100
  200 NA=NA
C     WRITE (6,11) NA,ILCW,ILA,NHEX
C     IF (ILCW.NE.0)  WRITE (6,13) (LCW(I),I=1,ILCW)
C     WRITE (6,13) (LA(I),I=1,ILA)
      RETURN
      END
      SUBROUTINE WRITPN(IFTN,LN,LA,NA,NTUPL)
C     ENTRY WRPN (NA)
C     ENTRY INITPN (RNAME)
C     ENTRY EXITPN
C
C      FUNCTION:
C
C      WRITPN:WRITE ONE SELF DEFINED PACKED LOGICAL RECORD OF INDEX
C             N-TUPLES.MUST BE USED FOR FIRST WRITE.
C      WRPN:  WRITE ONE SELF DEFINED PACKED LOGICAL RECORD OF INDEX
C             N-TUPLES.MAY BE USED FOR WRITES AFTER THE
C             FIRST,IF ALL ARGUMENTS OTHER THAN NA HAVE SAME VALUE AS
C             LAST EXECUTED WRITPN.
C      INITPN:INITIALIZE PACKING STATISTICS.(EXECUTE BEFORE FIRST
C             WRITPN OR WRPN).
C      EXITPN:PRINT PACKING STATISTICS ACCUMULATED OVER ALL WRITES (BY
C             WRITPN OR WRPN) EXECUTED SINCE THE LAST INITPN.
C
C      ARGUMENT LIST:
C
C      IFTN:  FORTRAN NUMBER OF SEQUENTIAL ACCESS DATASET.
C      LN:    UNPACKED ARRAY BEING WRITTEN.
C      LA:    ARRAY WHERE PACKING IS DONE.CAN BE SAME STORAGE AREA AS
C             LN,IF UNPACKED N-TUPLES CAN BE OVERWRITTEN.
C      NA:    IABS(NA) IS THE NUMBER OF N-TUPLES IN A.(CAN BE 0).
C      NTUPL: IABS(NTUPL) IS THE N VALUE OF THE N-TUPLE.
C             +VE NTUPL MEANS PACK;-VE NTUPL MEANS DO NOT PACK.
C      RNAME: USER GIVEN NAME OF DATASET.
C
      IMPLICIT REAL*8(A-H,O-Z),LOGICAL*1(L),INTEGER*4(I-K,M,N)
      DIMENSION LN(2),LA(2),LWORK(4),LPACK(8),LNTPLC(8),
     1    LWORD(4),IPTWO(8),LCW(1000)
      DIMENSION RNAME(2)
C BHL
      DIMENSION LNTJ(4),LNJ(4)
C
      EQUIVALENCE (IWORK,LWORK(1)),(IWORD,LWORD(1))
C  BHL
      EQUIVALENCE (INTJ,LNTJ(1)),(INJ,LNJ(1))
C
C      MAXIMUM LENGTH OF CODE WORD BUFFER.IF CHANGED,THEN ALSO
C      CHANGE THE DIMENSION OF LCW
      DATA NCWBUF/1000/
      DATA IZERO/0/
C      IFLGNT  FLAG FOR ACCUMULATING PACKING STATISTICS
C          =0  NO STATISTICS
C          =1  ACCUMULATE STATISTICS
      DATA IFLGNT/0/
   10 FORMAT (' ',5Z20)
   11 FORMAT (' ',10I8)
   12 FORMAT (' ',5F20.10)
   13 FORMAT (' ',5(4X,8Z2))
   20 FORMAT (' DATA LIST ',20X,8A8/' ','HAS BEEN PACKED.',I9,
     1   1X,I1,'-TUPLES INTO ',I9,' BYTES,PACKING FRACTION=',F8.4,
     2   2X,'NTUPL=',I4/' ',I9,' CODE WORD BYTES,',I9,
     3   ' DATA BYTES,',I9,' LOGICAL RECORDS')
      MNTUPL=IABS(NTUPL)
      NCWBFM=NCWBUF-2
C      TABULATE POWERS OF 2
C    BHL
      INJ=0
      INTJ=0
C
      IPTWO(1)=1
      DO 80 I=2,8
   80 IPTWO(I)=IPTWO(I-1)*2
      GO TO 801
      ENTRY WRPN (NA)
  801 CONTINUE
C      SAVE NA WITH SIGN IN ISAVNA.USER WILL SET IT NEGATIVE IF
C      THIS WRITE CALL COMPLETES THE WRITING OF THE DATA LIST,
C      AND ON READING HE WANTS TO TERMINATE READING BY TESTING
C      ON SIGN OF NA.
      ISAVNA=NA
      NA=IABS(NA)
      NF=NA*MNTUPL
C     WRITE (6,11) NA,NTUPL
C     WRITE (6,13) (LN(I),I=1,NF)
      IF (NA.EQ.0)  GO TO 900
C      IF  NTUPL.LT.0  DO NOT PACK
      IF (NTUPL.LT.0)  GO TO 500
C      IFINAL  COUNT OVER PAIRS OF LOGICAL RECORDS
      IFINAL=0
C      ICOUNT  COUNT OVER NA (# OF N-TUPLES)
      ICOUNT=0
C      INTPLP  COUNT OVER PICKUP FROM LN
      INTPLP=0
C      STORE DATA BYTES FOR FIRST N-TUPLE IN CURRENT PAIR OF
C      LOGICAL RECORDS
   90 INA=1
      ILCW=0
      IWORD=1
      ILA=MNTUPL
      DO 100 J=1,MNTUPL
      LA(J)=LN(INTPLP+J)
  100 LNTPLC(J)=LN(INTPLP+J)
      INTPLP=INTPLP+MNTUPL
      ICDIFC=IPTWO(MNTUPL+1)-1
      GO TO 273
C      COMPARE WITH LAST N-TUPLE. COMPUTE NDIF,ICDIF,LPACK(J),J=1,NDIF
  150 NDIF=0
      ICDIF=0
      DO 170 J=1,MNTUPL
      JJ=INTPLP+J
C    BHL
C     IF (LNTPLC(J).EQ.LN(JJ))  GO TO 170
      LNTJ(4)=LNTPLC(J)
      LNJ(4)=LN(JJ)
      IF(INTJ.EQ.INJ)GO TO 170
C
      NDIF=NDIF+1
      LPACK(NDIF)=LN(JJ)
      ICDIF=ICDIF+IPTWO(MNTUPL-J+1)
  165 LNTPLC(J)=LN(JJ)
  170 CONTINUE
  250 IF (IWORD.EQ.255)  GO TO 280
      IF (ICDIF.NE.ICDIFC)  GO TO 280
      IWORD=IWORD+1
C      STORE PACKED BYTES INTO LA
  260 IF (NDIF.EQ.0)  GO TO 272
      DO 270 J=1,NDIF
  270 LA(ILA+J)=LPACK(J)
  272 INTPLP=INTPLP+MNTUPL
      ILA=ILA+NDIF
      INA=INA+1
  273 ICOUNT=ICOUNT+1
      IF (NA.GT.ICOUNT)  GO TO 150
  275 IFINAL=-IFINAL-1
      GO TO 280
C      CONSTRUCT AND STORE OLD CODEWORD
  280 IF (IWORD.GE.IPTWO(8-MNTUPL))  GO TO 290
      IWORK=IWORD*IPTWO(MNTUPL+1)
      IWORK=IWORK+ICDIFC
      LCW(ILCW+1)=LWORK(4)
      ILCW=ILCW+1
      GO TO 340
  290 IWORK=ICDIFC+128
      LCW(ILCW+1)=LWORK(4)
      LCW(ILCW+2)=LWORD(4)
      ILCW=ILCW+2
      GO TO 340
  300 IWORD=1
      ICDIFC=ICDIF
      GO TO 260
C      TEST CODE WORD BUFFER OVERFLOW.IF OVERFLOW,WRITE CURRENT
C      PAIR OF LOGICAL RECORDS
  340 IF (ILCW.GT.NCWBFM)  GO TO 350
C      TEST IF PROCESSING COMPLETE.IF NOT,START A NEW CODE WORD
C      AND STORE LAST PACKED BYTES
      IF (IFINAL.GE.0)  GO TO 300
  350 IF (IFINAL.GE.0)  IFINAL=IFINAL+1
C      WRITE CURRENT PAIR OF LOGICAL RECORDS
C      WRITE INA WITH NEGATIVE SIGN IF THIS CALL TO WRITPN OR WRPN
C      COMPLETES THE WRITING OF THIS DATA LIST
      IWNA=INA
      IF (ISAVNA.LT.0)  IWNA=-IWNA
      WRITE (IFTN) IFINAL,IWNA,ILCW,ILA,NTUPL
C      KEEP STATISTICS ON DATASET IF CALL INITPN WAS CALLED
      IF (IFLGNT.EQ.0)  GO TO 360
      NTBYTE=NTBYTE+ILA+ILCW+20
      NNTUPL=NNTUPL+INA
      NCB=NCB+ILCW
      NDB=NDB+ILA
      NLR=NLR+2
  360 CALL WRITB1 (IFTN,LCW,ILCW,LA,ILA)
  370 IF (IFINAL.LT.0)  GO TO 1000
      GO TO 90
C      NO PACKING:  WRITE SINGLE PAIR OF LOGICAL RECORDS
  500 IFINAL=-1
      WRITE (IFTN) IFINAL,ISAVNA,IZERO,NF,NTUPL
      CALL WRITB4 (IFTN,LN,NF)
      IF (IFLGNT.EQ.0)  GO TO 1000
      NTBYTE=NTBYTE+NF+20
      NNTUPL=NNTUPL+NA
      NDB=NDB+NF
      NLR=NLR+2
      GO TO 1000
  900 IFINAL=-1
      DO 901 I=1,2
  901 WRITE (IFTN) IFINAL,NA,NA,NA,NTUPL
      IF (IFLGNT.EQ.0)  GO TO 1000
      NTBYTE=NTBYTE+40
      NLR=NLR+2
      GO TO 1000
 1000 NTBYTE=NTBYTE
C     WRITE (6,11) NA,NTUPL,NTBYTE
      RETURN
      ENTRY INITPN (RNAME)
      IFLGNT=1
      NTBYTE=0
      NNTUPL=0
      NCB=0
      NDB=0
      NLR=0
      RETURN
      ENTRY EXITPN
      PF=1.D10
      IF (NNTUPL.EQ.0)  GO TO 1100
      PFN=NTBYTE
      PFD=MNTUPL*NNTUPL
      PF=PFN/PFD
 1100 WRITE (6,20) (RNAME(I),I=1,8),NNTUPL,MNTUPL,NTBYTE,PF,
     1    NTUPL,NCB,NDB,NLR
      IFLGNT=0
      NNTUPL=0
      RETURN
      END
      SUBROUTINE READPN (IFTN,LN,LA,NA,NTUPL,IERR,IEND)
C     ENTRY RDPN (NA)
C     ENTRY ADVPN (IFTN,NA,IERR,IEND)
C
C      FUNCTION:
C
C      READPN:READ ONE SELF DEFINED PACKED LOGICAL RECORD OF INDEX
C             N-TUPLES.MUST BE USED FOR FIRST READ.
C      RDPN:  READ ONE SELF DEFINED PACKED LOGICAL RECORD OF INDEX
C             N-TUPLES.MAY BE USED FOR READS AFTER THE
C             FIRST,IF ALL ARGUMENTS OTHER THAN NA HAVE SAME VALUE AS
C             LAST EXECUTED READPN.
C      ADVPN: ADVANCE OVER ONE SELF DEFINED PACKED LOGICAL RECORD OF
C             INDEX N-TUPLES.
C
C      ARGUMENT LIST:
C
C      IFTN:  FORTRAN NUMBER OF SEQUENTIAL ACCESS DATASET.
C      LN:    ARRAY OF INDEX N-TUPLES RETURNED TO USER.
C      LA:    ARRAY WHERE PACKED N-TUPLES ARE READ FROM IFTN BEFORE
C             UNPACKING.CAN BE SAME STORAGE AREA AS LN IF UNPACKED
C             N-TUPLES CAN BE OVERWRITTEN.
C      NA:    RETURNED TO USER FROM SELF DEFINED PACKED LOGICAL RECORD.
C             SIGN AS GIVEN BY USER.
C      NTUPL: RETURNED TO USER FROM SELF DEFINED PACKED LOGICAL RECORD.
C      IERR:  =0,IF NO ERR ON FORTRAN READ.
C             =1,IF ERR CONDITION ON FORTRAN READ.
C      IEND:  =0,IF NO END ON FORTRAN READ.
C             =1,IF END CONDITION ON FORTRAN READ.
C
      IMPLICIT REAL*8(A-H,O-Z),LOGICAL*1(L),INTEGER*4(I-K,M,N)
      DIMENSION  LN(2),LA(2),LCW(1000),LNTPLC(8),LWORK(4),
     1    INTPLC(2),IPTWO(8),LWORD(4),IDIF(8)
      EQUIVALENCE (IWORK,LWORK(1)),(INTPLC(1),LNTPLC(1)),
     1     (IWORD,LWORD(1))
   10 FORMAT (' ',5Z20)
   11 FORMAT (' ',10I8)
   12 FORMAT (' ',5F20.10)
   13 FORMAT (' ',5(4X,8Z2))
C      TABULATE POWERS OF 2
      IPTWO(1)=1
      DO 80 J=2,8
   80 IPTWO(J)=IPTWO(J-1)*2
      ENTRY RDPN (NA)
      ISAVNA=0
C      NAFLG  FLAG FOR HANDLING NA=0 CASE,WHERE TWO LOGICAL RECORDS
C      MUST BE READ BUT NO N-TUPLES ARE RETURNED
      NAFLG=0
      INAS=0
      INAF=0
      IERR=0
      IEND=0
C      READ FIRST OF CURRENT LOGICAL RECORD PAIR
  100 READ (IFTN,ERR=101,END=102)  IFINAL,INA,ILCW,ILA,NTUPL
      IF (INA.LT.0)  ISAVNA=1
      INA=IABS(INA)
C     WRITE (6,11) IFINAL,INA,ILCW,ILA,NTUPL
      GO TO 110
  101 IERR=IERR+1
      GO TO 900
  102 IEND=IEND+1
      GO TO 900
  110 INAF=INAF+INA
      MNTUPL=IABS(NTUPL)
      IF (INA.EQ.0)  GO TO 120
      IF (NTUPL.GT.0)  GO TO 150
C      READ UNPACKED N-TUPLES INTO LN,AND GET OUT
      CALL READB4 (IFTN,LN,ILA,IERR,IEND)
      IF ((IERR.EQ.1).OR.(IEND.EQ.1))  GO TO 900
      GO TO 800
  120 IF (NAFLG.EQ.1)  GO TO 800
      NAFLG=NAFLG+1
      GO TO 100
C      IN THE CASE THAT N-TUPLES HAVE BEEN PACKED,READ THE SECOND
C      OF THE CURRENT LOGICAL RECORD PAIR
  150 ILAC=(MNTUPL*INAF)-ILA
      CALL READB1 (IFTN,LCW,ILCW,LA(ILAC+1),ILA,IERR,IEND)
      IF ((IERR.EQ.1).OR.(IEND.EQ.1))  GO TO 900
  310 ILCWC=0
      INTPLC(1)=0
      INTPLC(2)=0
C      PICK UP AND DECODE CODEWORD
  315 IWORD=0
      IWORK=0
      LWORK(4)=LCW(ILCWC+1)
      IWORK1=IWORK
      IF (IWORK.GE.128)  GO TO 318
      IWORK=IWORK*IPTWO(9-MNTUPL)
      LWORD(4)=LWORK(3)
      ICDIF=IWORK1-IWORD*IPTWO(MNTUPL+1)
      ILCWC=ILCWC+1
      GO TO 320
  318 ICDIF=IWORK-128
      LWORD(4)=LCW(ILCWC+2)
      ILCWC=ILCWC+2
  320 NDIF=0
      MM=MNTUPL+1
      DO 330 J=1,MNTUPL
      MMJ=MM-J
      IF (ICDIF.LT.IPTWO(MMJ))  GO TO 330
      NDIF=NDIF+1
      IDIF(NDIF)=J
      ICDIF=ICDIF-IPTWO(MMJ)
  330 CONTINUE
      DO 350 I=1,IWORD
      IF (NDIF.EQ.0)  GO TO 336
      DO 335 J=1,NDIF
  335 LNTPLC(IDIF(J))=LA(ILAC+J)
      ILAC=ILAC+NDIF
  336 DO 340 K=1,MNTUPL
  340 LN(INAS+K)=LNTPLC(K)
  350 INAS=INAS+MNTUPL
      IF (ILCWC.NE.ILCW)  GO TO 315
      IF (IFINAL.GE.0)  GO TO 100
  800 NA=INAF
      NF=NA*MNTUPL
C      RETURN NA WITH A NEGATIVE SIGN IF THIS COMPLETES THE READING
C      OF THE DATA LIST
      IF (ISAVNA.EQ.1)  NA=-NA
C     WRITE (6,11) NA
C     WRITE (6,13)  (LN(I),I=1,NF)
  900 RETURN
      ENTRY ADVPN (IFTN,NA,IERR,IEND)
C      SIMULATES FORTRAN SKIP OVER A SINGLE RECORD,BY READING WITH
C      NO IO LIST.INTHE 'PACK' FORMAT THE SKIP IS OVER THE DATA
C      WRITTEN BY A CALL TO WRITPN OR WRPN.
C      NEGATIVE NA CAN BE USED AS A TERMINATION FLAG
      NA=0
  901 READ (IFTN,ERR=101) IFINAL,INA
      NA=NA+INA
      READ (IFTN,ERR=101,END=102)
      IF (IFINAL.GT.0)  GO TO 901
      RETURN
      END
      SUBROUTINE RETPN (IFTN,LCW,ILCW,LA,ILA,NA,NTUPL,IERR,IEND)
C
C      FUNCTION:
C
C      RETPN: READ ONE SELF DEFINED PACKED LOGICAL RECORD OF INDEX
C             N-TUPLES,AND RETURN TO THE USER IN PACKED
C             FORM.
C
C      ARGUMENT LIST:
C
C      IFTN:  FORTRAN NUMBER OF SEQUENTIAL ACCESS DATASET.
C      LCW:   ARRAY OF CODEWORDS RETURNED TO USER.
C      ILCW:  NUMBER OF BYTES IN LCW.
C      LA:    ARRAY OF PACKED DATA BYTES RETURNED TO USER.
C      ILA:   NUMBER OF BYTES IN LA.
C      NA:    RETURNED TO USER FROM SELF DEFINED PACKED LOGICAL RECORD.
C             SIGN AS GIVEN BY USER.
C      NTUPL: RETURNED TO USER FROM SELF DEFINED PACKED LOGICAL RECORD.
C      IERR:  =0,IF NO ERR ON FORTRAN READ.
C             =1,IF ERR CONDITION ON FORTRAN READ.
C      IEND:  =0,IF NO END ON FORTRAN READ.
C             =1,IF END CONDITION ON FORTRAN READ.
C
      IMPLICIT REAL*8(A-H,O-Z),LOGICAL*1(L),INTEGER*4(I-K,M,N)
      DIMENSION LCW(2),LA(2)
   10 FORMAT (' ',5Z20)
   11 FORMAT (' ',10I8)
   12 FORMAT (' ',5F20.10)
   13 FORMAT (' ',5(4X,8Z2))
      NAFLG=0
      ILCW=0
      ILA=0
      NA=0
  100 READ (IFTN,ERR=101,END=102) IFINAL,NAC,ILCWC,ILAC,NTUPL
      MNAC=IABS(NAC)
C     WRITE (6,11) IFINAL,NAC,ILCWC,ILAC,NTUPL
      GO TO 120
  101 IERR=1
      GO TO 200
  102 IEND=1
      GO TO 200
  120 ILCWS=ILCW+1
      ILAS=ILA+1
      ILCW=ILCW+ILCWC
      ILA=ILA+ILAC
      NA=NA+NAC
      MNTUPL=IABS(NTUPL)
      NF=MNTUPL*MNAC
      IF (NAC.EQ.0)  GO TO 130
      IF (NTUPL.LT.0)  GO TO 140
      GO TO 150
  130 IF (NAFLG.EQ.1)  GO TO 200
      NAFLG=NAFLG+1
      GO TO 100
  140 CALL READB4 (IFTN,LA,NF,IERR,IEND)
      IF ((IERR.EQ.1).OR.(IEND.EQ.1))  GO TO 200
      GO TO 200
  150 CALL READB1 (IFTN,LCW(ILCWS),ILCWC,LA(ILAS),ILAC,IERR,IEND)
      IF ((IERR.EQ.1).OR.(IEND.EQ.1))  GO TO 200
  170 IF (IFINAL.GT.0)  GO TO 100
  200 NA=NA
C     WRITE (6,11) NA,ILCW,ILA,NTUPL
C     IF (ILCW.NE.0)  WRITE (6,13) (LCW(I),I=1,ILCW)
C     WRITE (6,13) (LA(I),I=1,ILA)
      RETURN
      END
      SUBROUTINE BACKPK (IFTN)
C      ENTRY BACKPN(IFTN)
C
C      FUNCTION:
C
C      BACKPK:BACKSPACE OVER ONE SELF DEFINED PACKED LOGICAL RECORD
C             OF FLOATING POINT REAL*8 NUMBERS.
C      BACKPN:BACKSPACE OVER ONE SELF DEFINED PACKED LOGICAL RECORD
C             OF INDEX N-TUPLES.
C
      IMPLICIT REAL*8(A-H,O-Z),LOGICAL*1(L),INTEGER*4(I-K,M,N)
      ENTRY BACKPN (IFTN)
      BACKSPACE IFTN
      BACKSPACE IFTN
      READ (IFTN) IFINAL,INA,ILCW,ILA,NHEX
      II=-2*IFINAL-1
      DO 100 I=1,II
  100 BACKSPACE IFTN
      RETURN
      END
      SUBROUTINE WRITB1 (IFTN,LCW,ILCW,LA,ILA)
C
C      FUNCTION:
C
C      WRITB1:BLOCK TRANSFER WRITE OF SECOND LOGICAL RECORD IN EACH
C             LOGICAL RECORD PAIR MAKING UP A SELF DEFINED PACKED
C             LOGICAL RECORD,FOR REAL*8'S WITH NHEX.NE.-100,
C             OR FOR INDEX N-TUPLES WITH +VE NTUPL.
C
      IMPLICIT REAL*8(A-H,O-Z),LOGICAL*1(L),INTEGER*4(I-K,M,N)
      DIMENSION LCW(ILCW),LA(ILA)
      WRITE (IFTN) LCW,LA
      RETURN
      END
      SUBROUTINE WRITB2 (IFTN,A,NA)
C
C      FUNCTION:
C
C      WRITB2:BLOCK TRANSFER WRITE OF SECOND LOGICAL RECORD IN EACH
C             LOGICAL RECORD PAIR MAKING UP A SELF DEFINED PACKED
C             LOGICAL RECORD,FOR REAL*8'S WITH NHEX.EQ.-100.
C
      IMPLICIT REAL*8(A-H,O-Z),LOGICAL*1(L),INTEGER*4(I-K,M,N)
      DIMENSION A(NA)
      WRITE (IFTN) A
      RETURN
      END
      SUBROUTINE WRITB4 (IFTN,LA,ILA)
C
C      FUNCTION:
C
C      WRITB4:BLOCK TRANSFER WRITE OF SECOND LOGICAL RECORD IN EACH
C             LOGICAL RECORD PAIR MAKING UP A SELF DEFINED PACKED
C             LOGICAL RECORD,FOR N-TUPLES WITH -VE NTUPL.
C
      IMPLICIT REAL*8(A-H,O-Z),LOGICAL*1(L),INTEGER*4(I-K,M,N)
      DIMENSION LA(ILA)
      WRITE (IFTN) LA
      RETURN
      END
      SUBROUTINE READB1(IFTN,LCW,ILCW,LA,ILA,IERR,IEND)
C
C      FUNCTION:
C
C      READB1:BLOCK TRANSFER READ OF SECOND LOGICAL RECORD IN EACH
C             LOGICAL RECORD PAIR MAKING UP A SELF DEFINED PACKED
C             LOGICAL RECORD,FOR REAL*8'S WITH NHEX.NE.-100,
C             OR FOR INDEX N-TUPLES WITH +VE NTUPL.
C
      IMPLICIT REAL*8(A-H,O-Z),LOGICAL*1(L),INTEGER*4(I-K,M,N)
      DIMENSION LCW(ILCW),LA(ILA)
   10 FORMAT (' ',5Z20)
   11 FORMAT (' ',10I8)
   12 FORMAT (' ',5F20.10)
   13 FORMAT (' ',5(4X,8Z2))
      READ (IFTN,ERR=100,END=101) LCW,LA
C     WRITE (6,13) LCW
C     WRITE (6,13) LA
      GO TO 150
  100 IERR=IERR+1
      GO TO 150
  101 IEND=IEND+1
  150 RETURN
      END
      SUBROUTINE READB2(IFTN,A,NA,IERR,IEND)
C
C      FUNCTION:
C
C      READB2:BLOCK TRANSFER READ OF SECOND LOGICAL RECORD IN EACH
C             LOGICAL RECORD PAIR MAKING UP A SELF DEFINED PACKED
C             LOGICAL RECORD,FOR REAL*8'S WITH NHEX.EQ.-100.
C
      IMPLICIT REAL*8(A-H,O-Z),LOGICAL*1(L),INTEGER*4(I-K,M,N)
      DIMENSION A(NA)
   10 FORMAT (' ',5Z20)
   11 FORMAT (' ',10I8)
   12 FORMAT (' ',5F20.10)
   13 FORMAT (' ',5(8Z2,4X))
      READ (IFTN,ERR=100,END=101) A
C     WRITE (6,10) A
C     WRITE (6,12) A
      GO TO 150
  100 IERR=IERR+1
      GO TO 150
  101 IEND=IEND+1
  150 RETURN
      END
      SUBROUTINE READB4 (IFTN,LA,ILA,IERR,IEND)
C
C      FUNCTION:
C
C      READB4:BLOCK TRANSFER READ OF SECOND LOGICAL RECORD IN EACH
C             LOGICAL RECORD PAIR MAKING UP A SELF DEFINED PACKED
C             LOGICAL RECORD,FOR N-TUPLES WITH -VE NTUPL.
C
      IMPLICIT REAL*8(A-H,O-Z),LOGICAL*1(L),INTEGER*4(I-K,M,N)
      DIMENSION LA(ILA)
   10 FORMAT (' ',5Z20)
   11 FORMAT (' ',10I8)
   12 FORMAT (' ',5F20.10)
   13 FORMAT (' ',5(4X,8Z2))
      READ (IFTN,ERR=100,END=101) LA
C     WRITE (6,13)  LA
      GO TO 150
  100 IERR=IERR+1
      GO TO 150
  101 IEND=IEND+1
  150 RETURN
      END
C **********  ROUTINE FOR COMPATIBILTIY WITH DOUBEL BUFFERED VERSION ****
      SUBROUTINE SRTIOI(IUNTI)
      RETURN
      ENTRY BUFIF(IUNTIC)
      IF(IUNTI.NE.IUNTIC)STOP ' SRTIOI-BUFIF ERROR '
      RETURN
      ENTRY SRTIOO(IUNTO)
      RETURN
      ENTRY BUFOF(IUNTOC)
      IF(IUNTO.NE.IUNTOC)STOP ' SRTIOO-BUFOF ERROR '
      RETURN
      END
      SUBROUTINE BUFI14(IUNIT,I1,I2,I3,I4,I5,I6,I7,I8,I9,I10,I11,I12,
     1                  I13,I14,*,*)
      READ(IUNIT,END=900,ERR=901)I1,I2,I3,I4,I5,I6,I7,I8,I9,I10,I11,I12,
     1                           I13,I14
      RETURN
      ENTRY BUFO14(IUNIT,I1,I2,I3,I4,I5,I6,I7,I8,I9,I10,I11,I12,I13,I14)
      WRITE(IUNIT)I1,I2,I3,I4,I5,I6,I7,I8,I9,I10,I11,I12,I13,I14
      RETURN
  900 CONTINUE
      RETURN 1
  901 CONTINUE
      RETURN 2
      END
      SUBROUTINE BUFIM(IUNIT,M,LBYTE,*,*)
      CHARACTER * 1 M(LBYTE)
      READ(IUNIT,END=900,ERR=910)M
      RETURN
      ENTRY BUFOM(IUNIT,M,LBYTE)
      WRITE(IUNIT)M
      RETURN
  900 CONTINUE
      RETURN 1
  910 CONTINUE
      RETURN 2
      END
