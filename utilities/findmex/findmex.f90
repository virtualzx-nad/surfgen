! findmex
!-------------------
! Search for minimum energy crossings on coupled potential generated by surfgen
! The program constructs intersection adapted coordinates to  search for intersection
! between a group of arbitrary adjacent states.  
!-------------------
! This is part of the surfgen program package.  To compile this program,
! first generate surfgen library with `make libs` in surfgen main directory,
! then run the `install.sh` script in the program's directory.
!-------------------
! (C) 2013 Yarkony Group, Johns Hopkins University
!-------------------
! Oct 2013        Xiaolei Zhu        Created 
!-------------------
program findmex
  implicit none
  integer::   ios,  isurf1, isurf2
  character*300 geomfile,str 
  integer :: natm , nst, ngeoms
  integer :: i,j
  double precision,allocatable  :: anum(:),masses(:),  hess(:,:), w(:)
  character*3,allocatable       :: aname(:)
  double precision,allocatable  :: cgeom(:)

  print *," ***************************************** "
  print *," *    findmex.x                           * "
  print *," ***************************************** "
  print *," Minimum energy crossing search on Surfgen potential surfaces"
  call initPotential()
  call getInfo(natm,nst)
  call DisableEnergyScaling()

! allocate arrays
  allocate(masses(natm))
  allocate(anum(natm))
  allocate(aname(natm))
  allocate(hess(natm*3,natm*3))
  allocate(w(3*natm))
  allocate(cgeom(3*natm))

  print "(A,I6)","Number of Atoms:  ",natm
  print "(A,I6)","Number of States: ",nst

! process arguments
! synposis:    findmex.x geom state1 state2
! Default values:
! geom        geom
! states      1 2
  isurf1 = 1 
  isurf2 = 2
  call get_command_argument(number=1,value=geomfile,status=ios)
  if(ios<-1)  &     ! input argument larger than container
      stop "Filename truncated.  Please use less than 300 characters"
  if(ios>0) then
    print *,"No filename suppied.  Using default."
    write(geomfile,"(A)"), "geom"
  else
    call get_command_argument(number=2,value=str,status=ios)
    if(ios<0) stop "Cannot get surface number from command line options.  Using default."
    if(ios==0)then
      read(str,*,iostat=ios)isurf1
      if(ios/=0) stop "Cannot get surface number from command line options.  Using default."
      call get_command_argument(number=3,value=str,status=ios)
      if(ios/=0) stop "Cannot get surface number from command line options.  Using default."
      read(str,*,iostat=ios)isurf2
      if(ios/=0) stop "Cannot get surface number from command line options.  Using default."
    end if
  end if
  if(isurf1<1.or.isurf1>=isurf2.or.isurf2>nst)stop"Invalid state range. Correct usage: findmex.x gmfile s1 s2"

  print *,"Reading input from input file "//trim(geomfile)
  call readColGeom(geomfile,1,natm,aname,anum,cgeom,masses)
 
  ! print initial geometry information
  print *,"--------------- Initial Geometries ------------------"
  call analysegeom(natm,cgeom)

  ! search for intersections
  call findx(natm,nst,cgeom,isurf1,isurf2,50,1d-2,1d0,1d-5)

  ! print final geometry information
  print *,"---------------  Final Geometries  ------------------"
  call analysegeom(natm,cgeom)
! deallocate arrays
  deallocate(masses)
  deallocate(anum)
  deallocate(aname)
  deallocate(hess)
  deallocate(w)
  deallocate(cgeom)
end program

!---print out geometry info ---
subroutine analysegeom(natoms,geom)
  implicit none
  integer, intent(in)   :: natoms
  double precision,intent(in)  ::  geom(3,natoms)
  double precision, parameter  ::  bohr2ang=0.529177249d0
  integer   ::  i,j,k,l
  double precision  ::  distmat(natoms,natoms), TLen = 1.7D0, d,d1(3),d2(3),d3(3),cpd(3)
  double precision,external  ::   dnrm2
  logical :: hasOOP(natoms)
  print *,"Cartesian Geometries in Atomic Units"
  print "(2x,3F15.10)",geom
  distmat = 0d0
  print "(/,A)","   Atom1   Atom2   Bond Length(Ang)"
  do i=1,natoms
    do j=i+1,natoms
      d = dnrm2(3,geom(:,i)-geom(:,j),1)*bohr2ang
      distmat(i,j) = d
      distmat(j,i) = d
      if(d<TLen)print "(2x,I5,3x,I5,3x,F12.8)",i,j,d
    end do
  end do

  print "(/,A)","   Atom1   Atom2   Atom3   Bond Angle (Degrees)"
  do i=1,natoms
    do j=1,natoms
     if(j==i .or. distmat(i,j)>TLen)cycle
     d1 = geom(:,j)-geom(:,i)
     d1 = d1/dnrm2(3,d1,1)
     do k=j+1,natoms
       if(k==i .or. distmat(i,k)>TLen)cycle
       d2 = geom(:,k)-geom(:,i)
       d2 = d2/dnrm2(3,d2,1)
       print "(2x,3(I5,3x),F12.4)",J,I,K, 90/Acos(0d0)* &
           ACOS(dot_product(d1,d2))
     end do!k
    end do !j
  end do   !i    

  hasOOP = .false.
  print "(/,A)","   Atom1   Atom2   Atom3   Atom4   Out-of-Plane Angle (Degrees)"
  do i=1,natoms
    do j=1,natoms
     if(j==i .or. distmat(i,j)>2*TLen)cycle
     d1 = geom(:,j)-geom(:,i)
     d1 = d1/dnrm2(3,d1,1)
     do k=j+1,natoms
       if(k==i .or. distmat(i,k)>2*TLen)cycle
       d2 = geom(:,k)-geom(:,i)
       d2 = d2/dnrm2(3,d2,1)
       do l=k+1,natoms
         if(l==i .or. distmat(i,l)>2*TLen.or.hasOOP(l))cycle
         d3 = geom(:,l)-geom(:,i)
         d3 = d3/dnrm2(3,d3,1)
         cpd(1) = d1(3)*(d2(2)-d3(2))+d2(3)*d3(2)-d2(2)*d3(3)+d1(2)*(d3(3)-d2(3))
         cpd(2) =-d2(3)*d3(1)+d1(3)*(d3(1)-d2(1))+d1(1)*(d2(3)-d3(3)) +d2(1)*d3(3)
         cpd(3) = d1(2)*(d2(1)-d3(1))+d2(2)*d3(1)-d2(1)*d3(2)+d1(1)*(d3(2)-d2(2))
         print "(2x,4(I5,3x),F12.4)",I,J,K,L, 90/Acos(0d0)* &
           asin((-d1(3)*d2(2)*d3(1)+d1(2)*d2(3)*d3(1)+d1(3)*d2(1)*d3(2)       &
                -d1(1)*d2(3)*d3(2)-d1(2)*d2(1)*d3(3)+d1(1)*d2(2)*d3(3))/      &
               dnrm2(3,cpd,1))   
         hasOOP(l)=.true.
       end do! l
     end do!k
    end do !j
  end do   !i    
end subroutine analysegeom


!---calculate averaged hessian at a certain geometry
subroutine calcHess(natoms,cgeom,nstate,state1,state2,stepsize,hessian,LDH)
  implicit none
  integer, intent(in)          :: natoms, nstate,state1,state2,LDH
  double precision,intent(in)  :: stepsize
  double precision,intent(in)  :: cgeom(3*natoms)
  double precision,intent(out) :: hessian(LDH,3*natoms)
  double precision   ::  mdif
  
  integer   ::   i,  j
  double precision  ::  dispgeom(3*natoms), dgrd(3*natoms)
  real*8    ::  h(nstate,nstate),cg(3*natoms,nstate,nstate),dcg(3*natoms,nstate,nstate),e(nstate)

  do i=1,3*natoms
    dispgeom=cgeom
    dispgeom(i)=dispgeom(i) - stepsize
    call EvaluateSurfgen(dispgeom,e,cg,h,dcg)
    dgrd  = 0
    do j=state1,state2
      dgrd  = dgrd-cg(:,j,j)
    end do
    dispgeom=cgeom
    dispgeom(i)=dispgeom(i) + stepsize
    call EvaluateSurfgen(dispgeom,e,cg,h,dcg)
    do j=state1,state2
      dgrd = dgrd+cg(:,j,j)
    end do
    hessian(i,1:3*natoms)= dgrd/2/stepsize/(state2-state1+1)
  end do!o=1,3*natoms
  mdif = 0
  do i=1,3*natoms-1
    do j=i+1,3*natoms
      mdif=max(mdif,abs(hessian(i,j)-hessian(j,i)))
      hessian(i,j)=(hessian(i,j)+hessian(j,i))/2
      hessian(j,i)=hessian(i,j)
    end do
  end do
  if(mdif>1d-5)print *,"maximum hermiticity breaking : ",mdif
end subroutine calcHess


!----search for minimum energy crossings on adiabatic surfaces 
!This is done by location critical points of the Lagrangian
! L=E+sum(l1.O)+sum(l2.dEd)
! O are off diagonal elements and dEd are difference of diagonal elements of the 
! degeneracy state group in an intersection adapted partially diagonal representation 
!---------------------
!After ab initio data are obtained, first construct an intersection adapted representation,
!This is then used to construct the Hessian and gradient of the Lagrangian.
!Newton-Raphson procedure is used to find the critical point.
!Energy part of the Hessian is done numerically
subroutine findx(natoms,nstate,cgeom,surf1,surf2,maxiter,shift,Etol,Stol)
  implicit none
  integer, intent(in)                                 ::  natoms,surf1,surf2,maxiter,nstate
  double precision,dimension(3*natoms),intent(inout)  ::  cgeom
  double precision,intent(in)                         ::  shift,Etol,Stol

  integer   :: ndeg  ! number of degenerate states
  integer   :: noffd ! number of off-diagonals that has to vanish 
  integer   :: nlag  ! number of Lagrange multipliers 
  integer   :: neq   ! total number of equations 
  real*8    ::  h(nstate,nstate),cg(3*natoms,nstate,nstate),dcg(3*natoms,nstate,nstate),e(nstate)
  double precision,dimension(3*natoms)           :: grad !gradient of average energy
  double precision,dimension(:,:),allocatable    :: hess     ! full hessian of lagrangian 
  double precision,dimension(:,:),allocatable    :: B    ! Coordinate-LM cross block and its self product 
  double precision,dimension(:),allocatable :: WORK
  double precision,dimension(:),allocatable :: lam, dlag    !lagrange multipliers and gradient of lagrangian
  double precision,dimension(:),allocatable :: w,b1,b2      ! evals of hessian and intermediate vectors 
  integer,dimension(:),allocatable :: IWORK
  integer           :: LIWORK, LWORK, itmp(1),INFO  
  integer  ::  iter  , i,j,lindex
  double precision            :: nrmG, nrmD,tmp(1)
  double precision, external  :: dnrm2
  double precision,  parameter  :: amu2au=1.822888484514D3,au2cm1=219474.6305d0
  double precision, parameter   :: MAXD = 1D-1

  ! allocate arrays
  ndeg = surf2-surf1+1
  noffd= ndeg*(ndeg-1)/2
  nlag = ndeg-1+noffd
  neq  = 3*natoms+nlag
  allocate(hess(neq,neq))
  allocate(lam(nlag))
  allocate(dlag(neq))
  allocate(w(neq))
  allocate(b1(neq))
  allocate(b2(neq))
  allocate(B(3*natoms,nlag))
  ! initialize work spaces
  call DSYEVD('V','U',neq,hess,neq,w,tmp,-1,itmp,-1,INFO)
  if(info/=0)print *,"DSYEVD allocation failed.  info=",info
  LWORK = int(tmp(1))
  LIWORK= itmp(1)
  allocate(WORK(LWORK))
  allocate(IWORK(LIWORK))

  print "(3(A,I4),A)","Searching for minimum between surfaces ",surf1," and ",&
                      surf2," in ",maxiter," iterations."
  print "(A)","  Convergence Tolerances"
  print "(A,E10.2,A,E10.2)","  Energy Gradient: ",Etol,"   Displacement:",Stol
  lam = 0d0
  do iter=1,maxiter
     call EvaluateSurfgen(cgeom,e,cg,h,dcg,.false.)
     print "(A,I5)","Iteration ",iter
     print *,"Energies:   "
     print "(10F20.4)",e*au2cm1 
     print *,"Lagrange Multipliers:   "
     print "(10F20.4)",lam
     ! use h and cg to store partially diagonalized representation and their gradients
     h = 0d0
     do i=1,nstate
       h(i,i) = e(i)
     end do
     ! construct Intersection Adapted Partially Diagonalized Representation
     call OrthogonalizeGH(h,cg,surf1,surf2,3*natoms,100,1d-10)
     ! get Hessian matrix of coordinate block
     call calcHess(natoms,cgeom,nstate,surf1,surf2,1D-5,hess,neq)
     ! get Hessian of mixed-coord-Lagrange multiplers block
     lindex=3*natoms+1
     do i=surf1+1,surf2
       hess(lindex,1:3*natoms)=cg(:,i,i)-cg(:,surf1,surf1) 
       hess(1:3*natoms,lindex)= hess(lindex,1:3*natoms)
       lindex=lindex+1
     end do
     ! part 2 : off diagonal element
     do i=surf1,surf2-1
       do j=i+1,surf2
         hess(lindex,1:3*natoms)=cg(:,i,j)
         hess(1:3*natoms,lindex)=cg(:,i,j)
         lindex=lindex+1
       end do
     end do
     !the LM-LM block is zero
     hess(3*natoms+1:neq,3*natoms+1:neq)=0d0
     ! get average gradient
     dlag = 0d0
     do i=surf1,surf2
        dlag(1:3*natoms) = dlag(1:3*natoms)+cg(:,i,i)
     end do
     dlag=dlag/(surf2-surf1+1)
     ! calculate optimized lagrange multipliers and update lagrangian gradient
     B = hess(1:3*natoms,3*natoms+1:neq)
     call updateLag(B,3*natoms,nlag,lam,dlag)
     ! calculate gradient of lagragian: coordinate part
     ! part 1 :  difference in diagonal part
     lindex=1
     do i=surf1+1,surf2
       dlag(1:3*natoms)=dlag(1:3*natoms)+lam(lindex)*(cg(:,i,i)-cg(:,surf1,surf1)) 
       lindex=lindex+1
     end do
     ! part 2 : off diagonal element
     do i=surf1,surf2-1
       do j=i+1,surf2
         dlag(1:3*natoms)=dlag(1:3*natoms)+lam(lindex)*cg(:,i,j)
         lindex=lindex+1
       end do
     end do
     ! calculate gradient of lagrangian: lagrange multipliers part
     lindex=3*natoms+1
     do i=surf1+1,surf2
       dlag(lindex)=h(i,i)-h(surf1,surf1)
       lindex=lindex+1
     end do
     ! part 2 : off diagonal element
     do i=surf1,surf2-1
       do j=i+1,surf2
         dlag(lindex)=h(i,j)
         lindex=lindex+1
       end do
     end do     
     ! invert the hessian
     call DSYEVD('V','U',neq,hess,neq,w,WORK,LWORK,IWORK,LIWORK,INFO)
     if(info/=0)print *,"DSYEVD failed.  info=",info
     ! hess. w. hess^T = hess_old
     ! so x= hess_old^-1.b = hess. w^-1. hess^T. b
     ! b1= hess^T.g       =>
     call DGEMV('T',neq,neq,1d0,hess,neq,dlag,1,0d0,b1,1)
     ! b1' = w^-1*b1
     do i=1,neq
      if(abs(w(i))<shift)then
         b1(i)=dble(0)
      else!
         b1(i)=b1(i)/w(i)
      end if!
     end do!
     ! b2 = hess.b1'
     call DGEMV('N',neq,neq,1d0,hess,neq,b1,1,0d0,b2,1)
     ! cgeom' = cgeom - H^-1.g
     nrmD=dnrm2(3*natoms,b2,1)
     if(nrmD>maxD)then
       b2=b2/nrmD*maxD
       nrmD=maxD
     end if
     nrmG=dnrm2(3*natoms,dlag,1)
     print 1000,nrmG,nrmD
     cgeom = cgeom - b2(1:3*natoms)
     lam   = lam   - b2(3*natoms+1:neq)
     if(nrmG<Etol.and.nrmD<Stol)then
       print *,"Optimization converged"
       return
     end if
  end do 
1000 format("         |Grd|=",E12.5,", |Disp|=",E12.5)
end subroutine findx 

!find optimized lagrange multipliers 
subroutine updateLag(b,nvibs,nlag,lam,grad)
  implicit none
  integer,intent(in)            ::  nvibs,nlag
  double precision,intent(in)   ::  b(nvibs,nlag)
  double precision,intent(inout)::  lam(nlag)
  double precision,intent(in)   ::  grad(nvibs)
  double precision :: btb(nlag,nlag),v(nlag),dl(nlag),w(nlag)
  integer::LWORK 
  double precision :: WORK(3*nlag*nlag+20)
  integer :: INFO,ipiv(nlag)
  LWORK=3*nlag*nlag+20
  !Bt.(g+B.deltaLam)=0
  !BtB.deltaLam=-Bt.g
  btb = matmul(transpose(b),b)
  
  ! v= -Bt.g
  call dgemv('T',nvibs,nlag,-1d0,B,nvibs,grad,1,0d0,v,1)

  call dsysv('U',nlag,1,BtB,nlag,ipiv,v,nlag,WORK,LWORK,INFO)
  if(INFO/=0)STOP "UpdateLag: DSYSV Failed."
  lam = v 
end subroutine updateLag
