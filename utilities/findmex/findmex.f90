! findmex
!-------------------
! Search for minimum energy crossings on coupled potential generated by surfgen
! The program constructs intersection adapted coordinates to  search for intersection
! between a group of arbitrary adjacent states.  
!-------------------
! This is part of the surfgen program package.  To compile this program,
! first generate surfgen library with `make libs` in surfgen main directory,
! then run the `install.sh` script in the program's directory.
!-------------------
! (C) 2013 Yarkony Group, Johns Hopkins University
!-------------------
! Oct 2013        Xiaolei Zhu        Created 
!-------------------
program findmex
  implicit none
  integer::   ios,  isurf1, isurf2
  character*300 geomfile,str 
  integer :: natm , nst, ngeoms
  integer :: i,j
  double precision,allocatable  :: anum(:),masses(:),  hess(:,:), w(:)
  character*3,allocatable       :: aname(:)
  double precision,allocatable  :: cgeom(:)
  integer,parameter :: MAXCONS=20
  double precision  :: shift, gtol, dtol, maxd, scale,cons_val(MAXCONS)
  integer           :: maxiter,ncons,cons_atm(3,MAXCONS)
  logical  :: ex
  integer,parameter :: fid=326
  NAMELIST /MEXOPT/  shift, gtol, dtol, maxd, maxiter, scale, ncons, cons_atm, cons_val


  print *," ***************************************** "
  print *," *    findmex.x                           * "
  print *," ***************************************** "
  print *," Minimum energy crossing search on Surfgen potential surfaces"
  call initPotential()
  call getInfo(natm,nst)
  call DisableEnergyScaling()

! read input values
  shift=1d-1
  gtol =1d-1
  dtol =1d-3
  maxd =1d0
  maxiter = 100
  scale = 1d0
  ncons = 0
  cons_atm=0
  cons_val=0d0
  inquire(file="mexopt.in",exist=ex)
  if(ex)then
    open(unit=fid,file="mexopt.in",access='sequential',form='formatted',&
        IOSTAT=ios, position='rewind',action='read',status='old')
    if(ios.eq.0)then
      read(unit=fid,nml=MEXOPT)
      if(ncons>MAXCONS)ncons=MAXCONS
      if(any(cons_atm(1:2,1:ncons)<1) .or. any(cons_atm(3,1:ncons)<0) .or. &
         any(cons_atm(1,1:ncons)==cons_atm(2,1:ncons)).or.any(cons_atm(1,1:ncons)==cons_atm(3,1:ncons)).or.&
         any(cons_atm(2,1:ncons)==cons_atm(3,1:ncons)) .or. any(cons_atm(:,1:ncons)>natm)) then
            print *,"input atom index for each coordinate constraints:"
            print "(3I4)",cons_atm(:,1:ncons)
            stop "invalid atom index"
      end if
      close(fid)
    end if
  end if

! allocate arrays
  allocate(masses(natm))
  allocate(anum(natm))
  allocate(aname(natm))
  allocate(hess(natm*3,natm*3))
  allocate(w(3*natm))
  allocate(cgeom(3*natm))

  print "(A,I6)","Number of Atoms:  ",natm
  print "(A,I6)","Number of States: ",nst

! process arguments
! synposis:    findmex.x geom state1 state2
! Default values:
! geom        geom
! states      1 2
  isurf1 = 1 
  isurf2 = 2
  call get_command_argument(number=1,value=geomfile,status=ios)
  if(ios<-1)  &     ! input argument larger than container
      stop "Filename truncated.  Please use less than 300 characters"
  if(ios>0) then
    print *,"No filename suppied.  Using default."
    write(geomfile,"(A)"), "geom"
  else
    call get_command_argument(number=2,value=str,status=ios)
    if(ios<0) stop "Cannot get surface number from command line options.  Using default."
    if(ios==0)then
      read(str,*,iostat=ios)isurf1
      if(ios/=0) stop "Cannot get surface number from command line options.  Using default."
      call get_command_argument(number=3,value=str,status=ios)
      if(ios/=0) stop "Cannot get surface number from command line options.  Using default."
      read(str,*,iostat=ios)isurf2
      if(ios/=0) stop "Cannot get surface number from command line options.  Using default."
    end if
  end if
  if(isurf1<1.or.isurf1>=isurf2.or.isurf2>nst)stop"Invalid state range. Correct usage: findmex.x gmfile s1 s2"

  print *,"Reading input from input file "//trim(geomfile)
  call readColGeom(geomfile,1,natm,aname,anum,cgeom,masses)
 
  ! print initial geometry information
  print *,"--------------- Initial Geometries ------------------"
  call analysegeom(natm,cgeom,aname,anum,masses,1.9d0,.true.)

  ! search for intersections
  call findx(natm,nst,cgeom,isurf1,isurf2,maxiter,shift,gtol,dtol,maxd,scale,ncons,cons_atm,cons_val)

  ! print final geometry information
  print *,"---------------  Final Geometries  ------------------"
  call analysegeom(natm,cgeom,aname,anum,masses,1.9d0,.true.)
! deallocate arrays
  deallocate(masses)
  deallocate(anum)
  deallocate(aname)
  deallocate(hess)
  deallocate(w)
  deallocate(cgeom)
end program

!---calculate averaged hessian at a certain geometry
subroutine calcHess(natoms,cgeom,nstate,state1,state2,stepsize,hessian,LDH)
  implicit none
  integer, intent(in)          :: natoms, nstate,state1,state2,LDH
  double precision,intent(in)  :: stepsize
  double precision,intent(in)  :: cgeom(3*natoms)
  double precision,intent(out) :: hessian(LDH,3*natoms)
  double precision   ::  mdif
  
  integer   ::   i,  j
  double precision  ::  dispgeom(3*natoms), dgrd(3*natoms)
  real*8    ::  h(nstate,nstate),cg(3*natoms,nstate,nstate),dcg(3*natoms,nstate,nstate),e(nstate)

  do i=1,3*natoms
    dispgeom=cgeom
    dispgeom(i)=dispgeom(i) - stepsize
    call EvaluateSurfgen(dispgeom,e,cg,h,dcg)
    dgrd  = 0
    do j=state1,state2
      dgrd  = dgrd-cg(:,j,j)
    end do
    dispgeom=cgeom
    dispgeom(i)=dispgeom(i) + stepsize
    call EvaluateSurfgen(dispgeom,e,cg,h,dcg)
    do j=state1,state2
      dgrd = dgrd+cg(:,j,j)
    end do
    hessian(i,1:3*natoms)= dgrd/2/stepsize/(state2-state1+1)
  end do!o=1,3*natoms
  mdif = 0
  do i=1,3*natoms-1
    do j=i+1,3*natoms
      mdif=max(mdif,abs(hessian(i,j)-hessian(j,i)))
      hessian(i,j)=(hessian(i,j)+hessian(j,i))/2
      hessian(j,i)=hessian(i,j)
    end do
  end do
  if(mdif>1d-5)print *,"maximum hermiticity breaking : ",mdif
end subroutine calcHess


!----search for minimum energy crossings on adiabatic surfaces 
!This is done by location critical points of the Lagrangian
! L=E+sum(l1.O)+sum(l2.dEd)
! O are off diagonal elements and dEd are difference of diagonal elements of the 
! degeneracy state group in an intersection adapted partially diagonal representation 
!---------------------
!After ab initio data are obtained, first construct an intersection adapted representation,
!This is then used to construct the Hessian and gradient of the Lagrangian.
!Newton-Raphson procedure is used to find the critical point.
!Energy part of the Hessian is done numerically
subroutine findx(natoms,nstate,cgeom,surf1,surf2,maxiter,shift,Etol,Stol,maxd,scale,nc,cons_atm,cons_val)
  implicit none
  integer, intent(in)                                 ::  natoms,surf1,surf2,maxiter,nstate,nc,cons_atm(3,nc)
  double precision,dimension(3*natoms),intent(inout)  ::  cgeom
  double precision,intent(in)                         ::  shift,Etol,Stol,maxd,scale,cons_val(nc)

  integer   :: ndeg  ! number of degenerate states
  integer   :: noffd ! number of off-diagonals that has to vanish 
  integer   :: nlag  ! number of Lagrange multipliers 
  integer   :: neq   ! total number of equations 
  real*8    ::  h(nstate,nstate),cg(3*natoms,nstate,nstate),dcg(3*natoms,nstate,nstate),e(nstate)
  double precision,dimension(3*natoms)          :: grad !gradient of average energy
  double precision,dimension(:,:),allocatable   :: hess     ! full hessian of lagrangian
  double precision,dimension(:,:),allocatable   :: B    ! Coordinate-LM cross block and its self product
  double precision,dimension(:),allocatable     :: WORK
  double precision,dimension(:),allocatable     :: coord_val
  double precision,dimension(:),allocatable     :: lam, dlag    !lagrange multipliers and gradient of lagrangian
  double precision,dimension(:),allocatable     :: w,b1,b2      ! evals of hessian and intermediate vectors
  integer,dimension(:),allocatable  :: IWORK
  double precision                  :: nrmG, nrmD,tmp(1),bval(12)
  double precision, external        :: dnrm2
  double precision, parameter       :: amu2au=1.822888484514D3,au2cm1=219474.6305d0
  integer           :: offs
  integer           :: LIWORK, LWORK, itmp(1),INFO
  integer           ::  iter  , i,j,lindex

  allocate(coord_val(nc))
  ! allocate arrays
  ndeg = surf2-surf1+1
  noffd= ndeg*(ndeg-1)/2
  nlag = ndeg-1+noffd+nc
  neq  = 3*natoms+nlag
  allocate(hess(neq,neq))
  allocate(lam(nlag))
  allocate(dlag(neq))
  allocate(w(neq))
  allocate(b1(neq))
  allocate(b2(neq))
  allocate(B(3*natoms,nlag))
  ! initialize work spaces
  call DSYEVD('V','U',neq,hess,neq,w,tmp,-1,itmp,-1,INFO)
  if(info/=0)print *,"DSYEVD allocation failed.  info=",info
  LWORK = int(tmp(1))
  LIWORK= itmp(1)
  allocate(WORK(LWORK))
  allocate(IWORK(LIWORK))

  print "(3(A,I4),A)","Searching for minimum between surfaces ",surf1," and ",&
                      surf2," in ",maxiter," iterations."
  print "(A)","  Convergence Tolerances"
  print "(A,E10.2,A,E10.2)","  Energy Gradient: ",Etol,"   Displacement:",Stol
  lam = 0d0
  do iter=1,maxiter
     call EvaluateSurfgen(cgeom,e,cg,h,dcg,.false.)
     print "(A,I5)","Iteration ",iter
     print "(A,20F20.4)","Energies : ",e*au2cm1 
     print "(A,20F20.4)","Lagrange Multipliers : ",lam
     ! use h and cg to store partially diagonalized representation and their gradients
     h = 0d0
     do i=1,nstate
       h(i,i) = e(i)
     end do
     ! construct Intersection Adapted Partially Diagonalized Representation
     call OrthogonalizeGH(h,cg,surf1,surf2,3*natoms,100,1d-10)
     ! get Hessian matrix of coordinate block
     call calcHess(natoms,cgeom,nstate,surf1,surf2,1D-5,hess,neq)
     ! get Hessian of mixed-coord-Lagrange multiplers block
     lindex=3*natoms+1
     do i=surf1+1,surf2
       hess(lindex,1:3*natoms)=cg(:,i,i)-cg(:,surf1,surf1) 
       hess(1:3*natoms,lindex)= hess(lindex,1:3*natoms)
       lindex=lindex+1
     end do
     ! part 2 : off diagonal element
     do i=surf1,surf2-1
       do j=i+1,surf2
         hess(lindex,1:3*natoms)=cg(:,i,j)
         hess(1:3*natoms,lindex)=cg(:,i,j)
         lindex=lindex+1
       end do
     end do
     ! part 3 : coordinate constraint part
     do i=1,nc
        hess(lindex,:) =  0d0
        if(cons_atm(3,i).ne.0)then
        ! it is an angle
            call bend(natoms,cons_atm(:,i),cgeom,coord_val(i),bval,5.72957795131d1,0,0d0) ! convert to degrees
            do j=1,3
                offs = 3*(cons_atm(j,i)-1)
                hess(lindex,offs+1:offs+3) =  bval(3*j-2:3*j)
            end do!j=1,3
        else !it is a distance
            call stre(natoms,cons_atm(1,i),cons_atm(2,i),cgeom,coord_val(i),bval)
            do j=1,2
                offs = 3*(cons_atm(j,i)-1)
                hess(lindex,offs+1:offs+3) =  bval(3*j-2:3*j)
            end do!j=1,2
        end if
        hess(1:3*natoms,lindex)=hess(lindex,1:3*natoms)
        lindex=lindex+1
     end do!i=1,nc
     !the LM-LM block is zero
     hess(3*natoms+1:neq,3*natoms+1:neq)=0d0
     ! get average gradient
     dlag = 0d0
     do i=surf1,surf2
        dlag(1:3*natoms) = dlag(1:3*natoms)+cg(:,i,i)
     end do
     dlag=dlag/(surf2-surf1+1)*scale
     ! calculate optimized lagrange multipliers and update lagrangian gradient
     B = hess(1:3*natoms,3*natoms+1:neq)
     call updateLag(B,3*natoms,nlag,lam,dlag)
     ! calculate gradient of lagragian: coordinate part
     ! part 1 :  difference in diagonal part
     lindex=1
     do i=surf1+1,surf2
       dlag(1:3*natoms)=dlag(1:3*natoms)+lam(lindex)*(cg(:,i,i)-cg(:,surf1,surf1)) 
       lindex=lindex+1
     end do
     ! part 2 : off diagonal element
     do i=surf1,surf2-1
       do j=i+1,surf2
         dlag(1:3*natoms)=dlag(1:3*natoms)+lam(lindex)*cg(:,i,j)
         lindex=lindex+1
       end do
     end do
     ! part 3: coordinate constraint part
     do i=1,nc
        dlag(1:3*natoms)=dlag(1:3*natoms)+lam(lindex)*hess(lindex,1:3*natoms)
        lindex=lindex+1
     end do
     ! calculate gradient of lagrangian: lagrange multipliers part
     lindex=3*natoms+1
     do i=surf1+1,surf2
       dlag(lindex)=h(i,i)-h(surf1,surf1)
       lindex=lindex+1
     end do
     ! part 2 : off diagonal element
     do i=surf1,surf2-1
       do j=i+1,surf2
         dlag(lindex)=h(i,j)
         lindex=lindex+1
       end do
     end do
     print "(A,15E15.5)","Coordinate values - constraints :",coord_val-cons_val
     do i=1,nc
        dlag(lindex)=coord_val(i)-cons_val(i)
        lindex=lindex+1
     end do
     do i=1,3*natoms
       hess(i,i)=hess(i,i)+shift
     end do
     ! invert the hessian
     call DSYEVD('V','U',neq,hess,neq,w,WORK,LWORK,IWORK,LIWORK,INFO)
     if(info/=0)print *,"DSYEVD failed.  info=",info
     ! hess. w. hess^T = hess_old
     ! so x= hess_old^-1.b = hess. w^-1. hess^T. b
     ! b1= hess^T.g       =>
     call DGEMV('T',neq,neq,1d0,hess,neq,dlag,1,0d0,b1,1)
     ! b1' = w^-1*b1
     do i=1,neq
      if(abs(w(i))<1d-10)then
         b1(i)=dble(0)
      else!
         b1(i)=b1(i)/w(i)
      end if!
     end do!
     ! b2 = hess.b1'
     call DGEMV('N',neq,neq,1d0,hess,neq,b1,1,0d0,b2,1)
     ! cgeom' = cgeom - H^-1.g
     nrmD=dnrm2(3*natoms,b2,1)
     if(nrmD>maxD)then
       b2=b2/nrmD*maxD
       nrmD=maxD
     end if
     nrmG=dnrm2(3*natoms,dlag,1)
     print 1000,nrmG,nrmD
     cgeom = cgeom - b2(1:3*natoms)
     lam   = lam   - b2(3*natoms+1:neq)
     if(nrmG<Etol.and.nrmD<Stol)then
       print *,"Optimization converged"
       return
     end if
  end do 
1000 format("         |Grd|=",E12.5,", |Disp|=",E12.5)
end subroutine findx 

!find optimized lagrange multipliers 
subroutine updateLag(b,nvibs,nlag,lam,grad)
  implicit none
  integer,intent(in)            ::  nvibs,nlag
  double precision,intent(in)   ::  b(nvibs,nlag)
  double precision,intent(inout)::  lam(nlag)
  double precision,intent(in)   ::  grad(nvibs)
  double precision :: btb(nlag,nlag),v(nlag),dl(nlag),w(nlag)
  integer::LWORK 
  double precision :: WORK(3*nlag*nlag+20)
  integer :: INFO,ipiv(nlag),i
  LWORK=3*nlag*nlag+20
  !Bt.(g+B.deltaLam)=0
  !BtB.deltaLam=-Bt.g
  btb = matmul(transpose(b),b)
  
  ! v= -Bt.g
  call dgemv('T',nvibs,nlag,-1d0,B,nvibs,grad,1,0d0,v,1)

  call dsysv('U',nlag,1,BtB,nlag,ipiv,v,nlag,WORK,LWORK,INFO)
  if(INFO/=0)then
    print *,"INFO=",INFO
    print *,"Bmatrix:"
    do i=1,nvibs
      print "(30F15.7)",b(i,:)
    end do
    STOP "updateLag: DSYSV Failed."
  end if
  lam = v 
end subroutine updateLag
